% --------------------------------------------------------------
%                         Template DM
% --------------------------------------------------------------
\documentclass[10pt]{article} %draft = show box warnings
\usepackage[a4paper, total={6.5in,10.2in}]{geometry} % Flexible and complete interface to document dimensions

\usepackage[utf8]{inputenc} % Accept different input encodings [utf8]
\usepackage[T1]{fontenc}    % Standard package for selecting font encodings
\usepackage{lmodern} % Good looking T1 font
% --------------------------------------------------------------
%                         Other Fonts
% --------------------------------------------------------------
%\usepackage{mathpazo} % Hermann Zapf's Palatino font
%\usepackage{kpfonts} % Kepler font
%\usepackage{mathptmx} % Times New Roman Like Font
%\usepackage{eulervm} %  AMS Euler (eulervm) math font.

% --------------------------------------------------------------
%                         Packages
% --------------------------------------------------------------
\usepackage[english]{babel} % Multilingual support
\usepackage{graphicx} % Enhanced support for graphics
\usepackage{float} % Improved interface for floating objects
\usepackage{amsmath,amsthm,amssymb} % American Mathematics Society facilities
\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}
\usepackage{verbatim}
\usepackage[title]{appendix}

% --------------------------------------------------------------
%                       Exercise Env
% --------------------------------------------------------------
\newtheoremstyle{problemstyle}  % <name>
{3pt}                   % <space above>
{3pt}                   % <space below>
{\normalfont}           % <body font>
{}                      % <indent amount}
{\bfseries}             % <theorem head font>
{\normalfont\bfseries\hspace{0.2 cm}}  % <punctuation after theorem head>
{.5em}                  % <space after theorem head>
{}                      % <theorem head spec (can be left empty, meaning `normal')>
\theoremstyle{problemstyle}

% Change Language
\newtheorem{exercise}{Task}	% Englsih
%\newtheorem{exercise}{Exercice} 	% French
%\newtheorem{exercise}{Exercício}	% Pt-BR

% Change counter type
%\renewcommand{\theexercise}{\Roman{exercise}. } % Exercise I)
\renewcommand{\theexercise}{\arabic{exercise}.} % Exercise 1.
%\renewcommand{\theexercise}{\Alph{exercise}.} % Exercise A.
%\renewcommand{\theexercise}{\alph{exercise}.} % Exercise a.

% --------------------------------------------------------------
%                       Listing conf
% --------------------------------------------------------------
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.95}
%\definecolor{backcolourOld}{rgb}{0.95,0.95,0.92}
 
\lstset{
  backgroundcolor=\color{backcolour},	% choose the background color;
  basicstyle=\footnotesize,				% the size of the fonts that are used for the code
  keywordstyle=\color{magenta},			% keyword style
  stringstyle=\color{codepurple},		% string literal style
  commentstyle=\color{codegreen},		% comment style
  numberstyle=\tiny\color{codegray},	% the style that is used for the line-numbers
  rulecolor=\color{black},				% if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  breakatwhitespace=false,				% sets if automatic breaks should only happen at whitespace
  breaklines=true,						% sets automatic line breaking
  frame=single,							% adds a frame around the code
  keepspaces=true,						% keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  numbers=left,							% where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,						% how far the line-numbers are from the code
  showspaces=false,						% show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=true,				% underline spaces within strings only
  showtabs=false,						% show tabs within strings adding particular underscores
  stepnumber=1,							% the step between two line-numbers. If it's 1, each line will be numbered
  tabsize=2,							% sets default tabsize to 2 spaces
  captionpos=t							% caption position
}

% --------------------------------------------------------------
%                       Custom commands, counters
% --------------------------------------------------------------
\renewcommand{\lstlistingname}{Algorithm}
\renewcommand*{\O}{\mathcal{O}}

% --------------------------------------------------------------

\begin{document}

% --------------------------------------------------------------
%                       Header
% --------------------------------------------------------------
\noindent
\normalsize\textbf{Conception et analyse d'algorithmes} \hfill \textbf{École Polytechnique}\\
\normalsize\textbf{INF 421} \hfill \textbf{\today}\vspace{20pt}
\centerline{\Large Programming Project P1 – X2015}\vspace{5pt}
\centerline{\Large \textbf{From ADN to formation of proteins : how to align sequences ?}}\vspace{3pt}
\centerline{Project proposed by Marie Albenque -- \texttt{ albenque@lix.polytechnique.fr}}\vspace{13pt}
\centerline{Lucas Lugão Guimarães -- \texttt{lucas.lugao-guimaraes@polytechnique.edu}}
\centerline{Alexandre Ribeiro João Macedo --  \texttt{alexandre.macedo@polytechnique.edu}}\vspace{20pt}
% --------------------------------------------------------------

%% http://www.lix.polytechnique.fr/~albenque/INF421-2016/Alignment_Project.pdf

\begin{exercise} % Task 1
We can solve the longest common subsequence (LCS) for two sequences $s=s_1\dots s_n$ and $t=t_1\dots t_m$ in a naive way by considering all the $2^{n}$ subsequences of $s$ and determining if it is a subsequence of $t$. The last step can be done with a complexity of $\O(m)$, which leaves the naive algorithm with a complexity of $\O(2^{n}m)$.
\end{exercise}

\begin{exercise} % Task 2
In order to solve the LCS in a more efficient way we can use dynamic programming (DP). We denote $LCS(s,t)$ the solution of the problem given the inputs $s=s_1\dots s_n$ and $t=t_1\dots t_m$. In the case where $s_m = t_n = u$, the solution will be $u$ appended to the end of the solution of $LCS(\hat{s}=s_1\dots s_{n-1}, \hat{t}=t_1\dots t_{m-1})$. In the case where $s_m \neq t_n$, the solution is the longest sequence between $LCS(\hat{s}=s_1\dots s_{n-1}, t)$ and $LCS(s, \hat{t}=t_1\dots t_{m-1})$. In a more straight-forward way, we can solve it as described in \cite{jones}. The algorithm \ref{alg:task2} is an implementation in Java of this DP whose time complexity is $\O(nm)$.

\end{exercise}

\begin{exercise} % Task 3

We can show the equivalence between the editing distance and the number of inserted hyphens added to the number mismatches, letters that are  different between sequences, by interpreting the action of adding an hyphen to a sequence, lets say $s$, as an insertion in this sequence or as a deletion in $t$ and interpreting a mismatch as a transform in either of these sequences. The algorithm \ref{alg:task3} computes and displays one optimal alignment.
 
\end{exercise}

\begin{exercise} % Task 4
To compute the alignment using the Blosum50 score matrix, we use the Needleman-Wunsch algorithm as described in \cite{durbin}. The algorithm \ref{alg:task4} is an implementation of this algorithm.

\end{exercise}

\begin{exercise} % Task 5
In this question, we use a variant of the previous algorithm that considers an affine gap penalty and ignores penalty gaps at the beginning and at the end of sequences, it can be classified as a semi-global alignment with affine gap penalty. The implementation is shown in the algorithm \ref{alg:task5}.

\end{exercise}

\begin{exercise} % Task 6
For the local alignment with affine gaps, we can use an algorithm based in the Smith-Waterman algorithm, described in \cite{durbin}. It is a particular case where we consider, in addition to the possibilities of adding a gap to one or the other sequence or not adding a gap, the possibility of stopping or starting at that point. This is implemented as a change in the DP, by adding the case $0$ when getting the maximum score in the recursion. The algorithm \ref{alg:task6} is the implementation in Java.

\end{exercise}

\begin{exercise} % Task 7
The algorithms presented so far are all exact, in a sense that they will return for sure the alignment with the best score but they all come with complexity of $\O(mn)$. If we use this to align a given sequence of size one thousand to a database of hundreds of millions of residues, the number of matrix entries will be the order of $10^{11}$ which would take a long time to compute, as explained in \cite{durbin}. In order to solve this problem, we can use heuristic algorithms that not necessarily return the best alignment but that can run much faster. Such a example is BLAST.
\end{exercise}

\begin{exercise} % Task 8
	content...
\end{exercise}

\begin{exercise} % Task 9
	content...
\end{exercise}

\begin{thebibliography}{3}
	
	\bibitem{jones} 
	Neil C. Jones and Pavel A. Pevzner. 
	\textit{An Introduction to Bioinformatics Algorithms}. 
	MIT Press, 2004
	
	\bibitem{durbin} 
	Richard Durbin, Sean R. Eddy, Anders Krogh and Graeme Mitchison. 
	\textit{Biological Sequence Analysis: Probabilistic Models of Proteins and Nucleic Acids}. 
	Cambridge University Press, 1998
	
\end{thebibliography}

\appendix
	\section{Implementations of the algorithms in Java} \label{app:alg}
	\lstinputlisting[caption={Longest common subsequence}, label={alg:task2}, language=java]{nada.java}
	\lstinputlisting[caption={Optimal alignment}, label={alg:task3}, language=java]{nada.java}
	\lstinputlisting[caption={Needleman-Wunsch}, label={alg:task4}, language=java]{nada.java}
	\lstinputlisting[caption={Semi-global alignment with affine gap penalty}, label={alg:task5}, language=java]{nada.java}
	\lstinputlisting[caption={Smith-Waterman with affine gaps}, label={alg:task6}, language=java]{nada.java}
\end{document}
